---
title: "Jensen Collaboration"
author: "Brian Gural"
date: "4/14/2023"
output: html_document
---

```{r setup, include=FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Load data and packages\
Our data includes bulk RNAseq from two conditions (sham surgery and myocardial infarction) and two genotypes (WT B6 and A KO).\
I've separated the original data into two documents. One for counts and sample names and one for the genotype/treatment data.\
For a snRNAseq reference, we're using a dataset produced by Christoph during his post-doc. It contains two samples, each the aggregate of several individual B6 LV nuclei suspensions.\ 
We're also loading several packages, which will be listed with their versions at the end of this document.\
```{r load data, include = F}
# load libraries
library(dplyr) # load first since we'll need dplyr::lapply()
libs <- c("Seurat", "DESeq2", "patchwork","SeuratDisk", "MuSiC", "reshape2",
          "tidyverse", "SingleCellExperiment","harmony", "SCpubr","shiny", "AUCell") # list libraries here
lapply(libs, require, character.only = T)
source("scripts/jensen/functions/decon_all.R")
#load data
sn <- LoadH5Seurat("data/jensen/raw/b6_sn.h5seurat")
pheno <- read.csv("data/jensen/raw/bulk_phenotypes.csv", header = 1, row.names = 1)
data <- read.csv("data/jensen/raw/jensen_counts.csv", header = 1, row.names = 1)
# first round of clustering + visualization
```

Some info on our unprocessed snRNAseq and bulk data:
```{r raw data info, include = T, echo = F}
sn
head(data)
```

**Clustering nuclei\

After loading our data and packages, we some standard single cell processing, including QC, normaliziation, scaling, neighbor analysis, and dimensional reduction. We'll also exclude nuclei above 5% mitocondrial gene expression.
```{r cluster1, echo=TRUE, message=FALSE, warning=FALSE}
sn.clust <- ClusterSeurat(sn, max.rna.ft = 4000,
                          max.mt.pt = 5, res = 0.1)
```

```{r cluster.1 data, echo=TRUE}
sn.clust
```

Now, we can visualize our data plotted on UMAPS. The top two plots are showing us how our clustering decided to group the nuclei and the right is how well we integrated our two samples.\
The lower two feature plots are showing percent mitocondrial RNA and number of transcripts counted in each nuclei. Mt RNA is a sign of cell-death even in single-cell data and is even more undesirable in single-nucleus data. Additionally, excessively high counts may indicate bi-nucleate sequencing droplets, which should also be excluded. All-and-all, we may want to consider removing select clusters and incorporating a doublet detection step in our pipeline. \
```{r cluster1.dim, echo=FALSE, fig.height=7, fig.width=8, message=FALSE, warning=FALSE}
# standard visuals for clusters and mitocondrial contaminants
dim.ft  <- c("seurat_clusters", "orig.ident")
feat.ft <- c("PercentMito", "nCount_RNA")

plotUMAP(data = sn.clust,
         dim.ft = dim.ft,
         feat.ft = feat.ft,
         nrow = 2, 
         ncol = 2)
```
### Removing mitocondrial clusters  
We're going to look at how many nuclei in each cluster contain more than 3% mitocondrial RNA. We'll set a cutoff off 20% of nuclei within a cluster and repeat the clustering without those nuclei. I've repeated this process three times in this document.

```{r remove mito cluster 1, echo=FALSE, message=FALSE, warning=FALSE, fig.align= 'center', include = F}
# select bad clusters/cells
# select bad clusters/cells
bad.clust <- mitoProps(sn.clust,
                  cutoff = 3) 
bad.clust.names <- as.numeric(names(bad.clust[bad.clust > 20]))
bad.cells <- WhichCells(sn.clust, 
                        idents = levels(sn.clust)[bad.clust.names]) # sets a 20% cutoff

sn.clust <- subset(sn, cells = bad.cells, invert = T)


# redo QC with removed cells 
sn.clust <- ClusterSeurat(sn.clust, max.rna.ft = 4000,
                          max.mt.pt = 3, res = 0.1)
bad.cells.1 <- bad.cells
```


```{r no mito dim, echo=FALSE, fig.height=5, fig.width=8, message=FALSE, warning=FALSE}
# standard visuals for clusters and mitocondrial contaminants
dim.ft  <- c(NULL)
feat.ft <- c("PercentMito")

plotUMAP(data = sn.clust,
         dim.ft = dim.ft,
         feat.ft = feat.ft,
         nrow = 1, 
         ncol = 1)
```

\
**Defining cell types\
To annotate the cells into clusters, I've  decided to  reference existing mouse single cell datasets. \
McLellan 2020 (DOI: 10.1161/CIRCULATIONAHA.119.045115) has a reasonably accessible list of marker genes for their clusters.\
They repeated their clustering, yielding both a broad and fine classification. So we'll be doing the process twice.\

*How it works\
I've reworked their data to be formatted as a data frame with 10 cell-type clusters matched with marker genes. \
In their original data, they also included AUC scores and percent of nuclei in and outside of the cluster which express the gene.\
There's a lot of differences between their data and ours, so I've left that extra info out.\
\

```{r load broad markers, echo=T, fig.height=10, fig.width=8, message=FALSE, warning=FALSE}
# load markers
markers.broad <- read.csv("data/processed/external/skelly_2020/mclellen_cell_markers_broad.csv")
head(markers.broad)
unique(markers.broad$cluster)
```
To make use of this, I'm employing the AUCell package. They have a wonderful vignette [here](https://bioconductor.org/packages/release/bioc/vignettes/AUCell/inst/doc/AUCell.html).\
Basically, it uses the gene sets I've supplied (40 - 150 genes per cell-type) and looks for cells where they're enriched via AUC.\
Single cell/nucleus is noisy, sparse, and variable, and AUCell does a few smart things to account for that.\
AUC scores are generally higher in more abundant genes, so it sets a threshold value for each gene. \
Also, each cell is considered independently to generate it's AUC score, so count variation has minimal effect on scores.\
\


```{r broad.cell.types AUC, echo=FALSE, fig.height=4, fig.width=7, message=FALSE, warning=FALSE}
# Split 'markers' into separate data frames for each unique subcluster
subclusters <- split(markers.broad, markers.broad$cluster)
# Extract the gene names from each subcluster data frame
subcluster_genes <- lapply(subclusters, function(x) x$gene)
# Create a list with named elements corresponding to each subcluster
geneSets <- setNames(subcluster_genes, names(subclusters))
# make expression matrix of single cell
my.expr <-  sn.clust@assays$RNA@counts
# Find  AUC for each cell by each type
cells_AUC <- AUCell_run(my.expr, geneSets)
cells_assignment <- AUCell_exploreThresholds(cells_AUC, plotHist=F, assign=TRUE)

# get the thresholds and report when/how they're passdd
selectedThresholds <- getThresholdSelected(cells_assignment)
```
Here is an example with our cardiomyocyte gene set:\
```{r AUC example, fig.width = 8, fig.height= 4, echo=T, message=FALSE, warning=FALSE}
# plot example bad and good types
geneSetName <- rownames(cells_AUC)[grep("cardiomyocytes", rownames(cells_AUC))]
AUCell_plotHist(cells_AUC[geneSetName,], aucThr = 0.197)
abline(v=0.197)

```
What we're seeing above is the cardiomyocyte-relevant AUC of every nuclei in our data. Under the hood, AUCell looks for a bi-modal distribution. Like we see above, that indicates that there is a population of nuclei expressing that gene set differently than the general cell population.\
\
And here is a less aesthetically pleasing example from B-cells:\
```{r AUC example, fig.width = 8, fig.height= 4, echo=T, message=FALSE, warning=FALSE}
# plot example bad and good types
geneSetName <- rownames(cells_AUC)[grep("B cells", rownames(cells_AUC))]
AUCell_plotHist(cells_AUC[geneSetName,], aucThr = 0.01165649)
abline(v=0.01165649)

```

*Narrowing labels\
The nature of this classification method means that cells can be labeled with more than one cell type. In my first round of analysis, most cells had >1 tag and rarely up to 4.\
To get around this, I've considered each AUC value for each cell (there is an AUC for each cell type it could be categorized). I then compared these values to the threshold value for the corresponding cell type (0.197 in the CM example earlier). For each value The nuclei were then tagged with whatever AUC/threshold value produced the highest ratio.\
\
An aside: This has its drawbacks, like labelling cell types which don't have a clearly bi-nomial AUC distribution. I'd like to add a filtration step to exclude normally or single-tailed distributed cell-types.\
```{r narrow broad AUC, eval=FALSE, fig.height=4, fig.width=8, message=FALSE, warning=FALSE, include=FALSE}
auc.val <- cells_AUC@assays@data@listData$AUC |>
              as.data.frame() |>
              t()

# Create an empty data frame to store the results
broad.cell.types <- data.frame(BroadCellType = character(), stringsAsFactors = FALSE)

# Iterate through each row (cell ID) of the auc.val matrix
for (i in 1:nrow(auc.val)) {
  # Get the cell ID row
  row_values <- auc.val[i, ]
  # Filter the columns with values greater than 0
  filtered_values <- row_values[row_values > 0]
  # Calculate the ratio between the value in auc.val and the corresponding cell type's threshold value from selectedThresholds
  ratios_for_cell_id_list <- lapply(names(filtered_values), function(cell_type) {
    filtered_values[cell_type] / selectedThresholds[[cell_type]]
  })
  ratios_for_cell_id <- unlist(ratios_for_cell_id_list, use.names = TRUE)
  names(ratios_for_cell_id) <- names(filtered_values)
  # Filter the ratios above 1
  filtered_ratios <- ratios_for_cell_id[ratios_for_cell_id > 1]
  # Find the cell type corresponding to the largest ratio for the current cell ID
  if (length(filtered_ratios) > 0) {
    max_ratio_cell_type <- names(filtered_ratios)[which.max(filtered_ratios)]
  } else {
    max_ratio_cell_type <- NA
  }
  # Store the corresponding cell type
  broad.cell.types <- rbind(broad.cell.types, data.frame(BroadCellType = max_ratio_cell_type, stringsAsFactors = FALSE))
}

# Set the rownames to the cell IDs and remove the CellID column
rownames(broad.cell.types) <- rownames(auc.val)

sn.clust <- AddMetaData(sn.clust, broad.cell.types)

```

```{r fine.cell.types, echo=FALSE, fig.height=4, fig.width=7, message=FALSE, warning=FALSE}
# load markers
markers.fine <- read.csv("data/processed/external/skelly_2020/mclellen_cell_markers.csv")
# Split 'markers' into separate data frames for each unique subcluster
subclusters <- split(markers.fine, markers.fine$subcluster)
# Extract the gene names from each subcluster data frame
subcluster_genes <- lapply(subclusters, function(x) x$gene)
# Create a list with named elements corresponding to each subcluster
geneSets <- setNames(subcluster_genes, names(subclusters))
# Find  AUC for each cell by each type
cells_AUC <- AUCell_run(my.expr, geneSets)
cells_assignment <- AUCell_exploreThresholds(cells_AUC, plotHist=F, assign=TRUE) 
# get the thresholds and report when/how they're passed
selectedThresholds <- getThresholdSelected(cells_assignment)
# get the AUC values
auc.val <- cells_AUC@assays@data@listData$AUC |>
              as.data.frame() |>
              t()
# Create an empty data frame to store the results
fine.cell.types <- data.frame(FineCellType = character(), stringsAsFactors = FALSE)

# Iterate through each row (cell ID) of the auc.val matrix
for (i in 1:nrow(auc.val)) {
  # Get the cell ID row
  row_values <- auc.val[i, ]
  # Filter the columns with values greater than 0
  filtered_values <- row_values[row_values > 0]
  # Calculate the ratio between the value in auc.val and the corresponding cell type's threshold value from selectedThresholds
  ratios_for_cell_id_list <- lapply(names(filtered_values), function(cell_type) {
    filtered_values[cell_type] / selectedThresholds[[cell_type]]
  })
  ratios_for_cell_id <- unlist(ratios_for_cell_id_list, use.names = TRUE)
  names(ratios_for_cell_id) <- names(filtered_values)
  # Filter the ratios above 1
  filtered_ratios <- ratios_for_cell_id[ratios_for_cell_id > 1]
  # Find the cell type corresponding to the largest ratio for the current cell ID
  if (length(filtered_ratios) > 0) {
    max_ratio_cell_type <- names(filtered_ratios)[which.max(filtered_ratios)]
  } else {
    max_ratio_cell_type <- NA
  }
  # Store the corresponding cell type
  fine.cell.types <- rbind(fine.cell.types, data.frame(FineCellType = max_ratio_cell_type, stringsAsFactors = FALSE))
}

# Set the rownames to the cell IDs and remove the CellID column
rownames(fine.cell.types) <- rownames(auc.val)
sn.clust <- AddMetaData(sn.clust, fine.cell.types)

```
After repeating with the fine cell types, we can add all of the annotations to our original single nucleus data and visualize the tags:\

```{r dim broad/fine, echo=FALSE, fig.height=8, fig.width=10, message=FALSE, warning=FALSE}
# standard visuals for clusters and mitocondrial contaminants
dim.ft  <- c("BroadCellType", "FineCellType")
plotUMAP(data = sn.clust,
         dim.ft = dim.ft,
         feat.ft = NULL,
         nrow = ceiling(length(dim.ft)/2), 
         ncol = 2)

```
*Defining Seurat clusters\
From the DimPlots above, it looks like the most clear cell types can be defined from the broad classification. To automatically pin those down to our own clusters, we'll apply  a Chi-Squared test between the Seurat clusters and our newly applied broad  cell-type labels.

```{r heatmap for celltypes, echo=FALSE, fig.height=6, fig.width=10, message=FALSE, warning=FALSE}
# Create a contingency table
contingency_table <- table(sn.clust$BroadCellType, sn.clust$seurat_clusters)
# Perform the chi-squared test
chi_squared_test <- chisq.test(contingency_table)
# Calculate the standardized residuals
observed_frequencies <- contingency_table
expected_frequencies <- chi_squared_test$expected
standardized_residuals <- (observed_frequencies - expected_frequencies) / sqrt(expected_frequencies)
# Create a heatmap of the standardized residuals
library(gplots)
heatmap.2(standardized_residuals, 
          trace = "none", 
          col = colorRampPalette(c("blue", "white", "red"))(25),
          main = "Heatmap of Standardized Residuals",
          xlab = "Seurat Clusters",
          ylab = "BroadCellType",
          margins = c(8, 12),
          key.title = "Standardized",
          key.xlab = "Residuals")
```
We can then look for the largest positive standardized residual for each seurat cluster and label it with the associated cell type. Sometimes, like with cluster 5 and macrophages, the association is of a duplicate or not very strong. In these cases, we'll get by applying a unique identifier. We can always reevaluate later.

```{r label clusters w chisq for celltypes, echo=FALSE, fig.height=6, fig.width=10, message=FALSE, warning=FALSE}
# Find the index of the largest value in each column of the normalized_contingency_table
max.indices <- apply(standardized_residuals, 2, which.max)
# Get the corresponding BroadCellType for each Seurat cluster
assigned.cell.types <- rownames(standardized_residuals)[max.indices] |>
                          make.unique()

#rename the clusters
names(assigned.cell.types) <- levels(sn.clust)
sn.clust <- RenameIdents(sn.clust, assigned.cell.types)

```

Here's what our final clusters and labels look like: 

```{r heatmap for celltypes, echo=FALSE, fig.height=7, fig.width=10, message=FALSE, warning=FALSE}
do_DimPlot(sn.clust, reduction = "umap", label = T, repel = T) + NoLegend()
```

**MuSiC and composition estimates**\
As I use it, MuSiC takes our single nucleus clusters and looks for deconvolution markers itself. It prioritizes markers that are expressed in most of the nuclei in a given cluster, consistant within the cluster, and variable between all of the clusters. It is also possible for us to supply our own markers.
```{r cluster2.dim, fig.width = 7, fig.height= 8, echo=FALSE, message=FALSE, warning=FALSE}
# music_prop needs exprs matrix
sn.sce <- as.SingleCellExperiment(sn.clust, assay = "RNA")
bulk.es <- ExpressionSet(assayData = as.matrix(data))
bulk.es <- exprs(bulk.es)
# estimate bulk composition with music
decon <- music_prop(bulk.mtx = bulk.es, sc.sce = sn.sce, markers = NULL,
                    clusters = "ident", samples = "orig.ident")
```

```{r cluster2.feat , fig.width = 7, fig.height= 4, echo=FALSE, message=FALSE, warning=FALSE}
# turn music output into graph-friendly dataframe
# also adds ratios of nuclei clusters from subject-matched samples
props <- processProps(decon.obj = decon,
                      seurat.obj = sn.clust,
                      subject.slot = "orig.ident")
decon.melt = melt(props, id.vars = c("names", "group"))
colnames(decon.melt) = c('Sub',"Type", 'CellType', 'Prop')
decon.melt$CellType = factor(decon.melt$CellType, levels = unique(decon.melt$CellType))
decon.melt$Prop <- as.numeric(decon.melt$Prop)

decon.bulk <- decon.melt[which(decon.melt$Type == "Bulk"),]
decon.bulk$genotype <- "wt"
decon.bulk[grepl("A", decon.bulk$Sub), 5] <- "ko"
decon.bulk$treatment <- "control"
decon.bulk[grepl("Lx", decon.bulk$Sub), 6] <- "mi"
```

```{r music, fig.width = 10, fig.height= 7, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(decon.bulk,
       aes(x=Sub, y=Prop, fill=CellType))  +
  geom_bar(stat='identity',
           position = "fill",
           width = 0.5,
           color = "black")+
  scale_fill_viridis_d(name = "Cell Type", labels = new.cluster.ids)+
  facet_wrap(~genotype + treatment, 
             scales = "free_x",
             labeller =  label_wrap_gen(multi_line=FALSE)) +
  ylab("Proportion") +
  theme( axis.text.x = element_text(color = "black", size = 15, angle = 30),
         strip.text = element_text(size = 20),
         title = element_text(size = 20),
         legend.text = element_text(size = 18),
         axis.ticks.x = element_blank()) +
  xlab("Samples")

```