---
title: "PseudoBulk V2"
author: "Brian Gural"
date: "2023-08-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load libs, message=FALSE, echo = F, warning=FALSE, results= 'hide', cache=FALSE, include=F}
# List libraries
libs <- c("Seurat", "ggplot2", "patchwork", "SeuratDisk","reshape2", "tidyverse",
          "SCpubr","shiny", "ggrepel", "gridExtra", "scCustomize", "httr", 
          "scales", "dplyr", "DeconvoBuddies", "readr", "SingleCellExperiment",
          "SummarizedExperiment", "Biobase", "ggmagnify", "stringr", "MuSiC",
          "ggforce", "DirichletReg", "readxl", "viridis", "DESeq2", "rlist",
          "purrr") # list libraries here
# Require all of them
lapply(libs, require, character.only = T)

# Also load in-house functions
source("jensen/scripts/functions/decon_all.R")
```

```{r load data, cache = TRUE, echo=FALSE, message=F, include = F}
sn <- LoadH5Seurat("jensen/data/processed/single_cell/merged_datasets/07192023/07192023_1.h5seurat")
```

```{r make downsampled df}
# Downsample 
sn.small <- sn |>
  GetAssayData(assay = "RNA", slot = "counts") |>
  as.matrix() |>
  SampleUMI(5000, verbose = T)

sn.small <- CreateSeuratObject(sn.small)
meta.features <- colnames(sn@meta.data)
for(i in meta.features){
  sn.small <- AddMetaData(sn.small, sn@meta.data[[i]], col.name = i)
}

Idents(sn.small) <- Idents(sn)

sn <- sn.small
```
## R Markdown

Having highly correlated variables in the design leads to unstable estimates of coefficients which will be reflected in large standard errors - Mike Love

This Rmd is meant to test the effect of different representations of composition in DESeq2 models. I've made simulated bulk RNAseq datasets of from range of cell type proportions, using snRNAseq as a gene expression profile reference. The null hypothesis is that compositional differences will not result in false positives between samples. The alternative hypothesis is that there will be differences and the can be accounted for with covariates which represent the composition.


```{r make pb functions, include = F}

# Function to make a data frame of cell type ratios
simulate_ratios <- function(major_cell, changing_cell, major_prop, changing_prop, 
                            cell_types, range, step_size, replicates, noise) {
  
  # get group tiers for major cell type
  # these are the percentages of the major cell type for which groups will be centered
  major_props_groups <- seq(major_prop - range, major_prop + range, step_size)
  
  # get values for major cell type
  # each value in the major_props_groups vector is used as a mean with n replicates pulled from a normal distribution with noise
  major_props <- lapply(major_props_groups, function(x){rnorm(replicates, x, noise)}) |>
                   unlist()
  
  # get group tiers for changing cell type
  changing_props_groups <- rev(seq(changing_prop - range, changing_prop + range, step_size))
  
  #get values for changing cell type
  changing_props <- lapply(changing_props_groups, function(x){rnorm(replicates, x, noise)}) |>
                      unlist()
  
  # Set major cell type and proportion
  minor <- cell_types[!(cell_types %in% c(major_cell, changing_cell))]
  
  
  # Define the range for proportions
  minor_props <- rep((1-major_props-changing_props)/length(minor), length(minor)) |>
                 matrix(ncol = length(minor)) |>
                 as.data.frame()
  colnames(minor_props) <- minor
  
  # set up props dataframe
  combos <- c(major_props, changing_props) |>
            matrix(ncol = 2) |>
            as.data.frame()
  colnames(combos) <- c(major_cell, changing_cell)
  
  # add minor cell types to props data frame
  props <- cbind(combos, minor_props)
  props$pct.change <- as.factor(rep(changing_props_groups - changing_prop, each = replicates))
  props$pct.change <- relevel(props$pct.change, ref = "0")
  rownames(props) <- paste0("mix_", 1:nrow(props))
  
  # add 3rd and 4th cell type proportions with a very small amount of noise
  props[,3] <- props[,3] * sample(rnorm(1000, 1, 0.0005), length(changing_props))
  props[,4] <- props[,4] * sample(rnorm(1000, 1, 0.0003), length(changing_props))
  
  # Normalize back to proportional sum == 1
  props[,1:5]  <- props[,1:5]/rowSums(props[,1:5])
  
  return(props)
}


# Function to sample cell IDs from a cell type, then aggregate their expression
AddCellProfile <- function(sn, count, cell_type){
    
    # Get the cell.ids that are the cell type of interest
    cell.ids  <- Idents(sn)[which(Idents(sn) == cell_type)] |>
              names() |>
              sample(size = count[cell_type], replace = T)
 
     # sum expression of cells with those ids
     cell.type.profile <- rowSums(sn@assays$RNA@counts[,cell.ids]) |>
       as.numeric()  
     assign(as.character(cell_type), cell.type.profile) # name the profile with the cell type
    return(get(as.character(cell_type)))
  }
  
AggCells <- function(sn, ratios, cell_count) {
  ratio.format <- ratios[1,] |> unlist()
  names(ratio.format) <- names(ratios)
  # Ensure ratios is a named list or named vector
  if (!is.list(ratio.format) && !is.vector(ratio.format)) {
    stop("ratios must be a named list or named vector")
  }
  # Cell counts by type
  cell_counts <- round(ratio.format * cell_count)
  #names(cell_counts) <- seq(0,length(ratio.format)-1, 1)
  dat <- sapply(1:length(cell_counts), function(x)
            {
            AddCellProfile(sn, cell_counts[x], names(cell_counts)[x])
            }
               ) |>
            rowSums()
  names(dat) <- rownames(sn)
  return(dat)
}


```


```{r make pb ratios}

major.cell <- "cardiomyocytes"
changing.cell <- "fibroblasts"
major.prop <- 0.5
changing.prop <- 0.25
range <- 0.2
step.size <- 0.01
replicates <- 3
noise <- 0.0001

ratios <- simulate_ratios(major_cell = major.cell, 
                                  changing_cell = changing.cell, 
                                  major_prop = major.prop, 
                                  changing_prop = changing.prop, 
                                  cell_types = cell.types, 
                                  range = range, 
                                  step_size = step.size, 
                                  replicates = replicates,
                                  noise = noise)

```

```{r make additive pseudobulk}
start <- Sys.time()
# Function to make a list of cell type ratios
cell.target <- 4000
# take each row of cell.ratios and put it into MakePseudoBulk 
pb.add <- sapply(1:nrow(ratios), function(x){AggCells(sn, ratios[x,-6], cell.target)}) |>
      as.data.frame()
colnames(pb.add) <- rownames(ratios)

end <- Sys.time() - start
```


```{r comp vars prep}
# Make clr comp
library(compositions)
clr.sample <- clr(ratios[,as.character(cell.types)])
colnames(clr.sample) <- paste0("clr.", colnames(clr.sample))

# Make PCA comp
pca.sample <- prcomp(t(ratios[,as.character(cell.types)]))$rotation |>
              as.data.frame()

pca.sample$pct.change <- ratios$pct.change
pca.sample$fb <- ratios$fibroblasts
pca.sample$cm <- ratios$cardiomyocytes

ggplot(pca.sample, aes(x = PC1, y = PC2, color = pct.change, size = fb)) +
  geom_point()


# add this info back to proportion dfs 
ratios <- cbind(ratios, clr.sample) |> 
                 cbind(pca.sample) 
```


```{r make deseq2 df }
# make df with clr, pca, and raw compositions
counts <- pb.add
counts.small <- counts[sample(rownames(counts), 2000),]
```

```{r deseq2 model comparison improvement}

models <- list(
  unadjusted    = ~ 0 + pct.change,
  raw_cm        = ~ 0 + pct.change + cardiomyocytes,
  raw_cm_fb     = ~ 0 + pct.change + cardiomyocytes + fibroblasts,
  raw_cm_fb_im  = ~ 0 + pct.change + cardiomyocytes + fibroblasts + immune,
  clr_cm        = ~ 0 + pct.change + clr.cardiomyocytes,
  clr_cm_fb     = ~ 0 + pct.change + clr.cardiomyocytes + clr.fibroblasts,
  clr_cm_fb_im  = ~ 0 + pct.change + clr.cardiomyocytes + clr.fibroblasts + clr.immune,
  pc1           = ~ 0 + pct.change + PC1,
  pc2           = ~ 0 + pct.change + PC1 + PC2)


```

```{r old deseq function, include = F}

sample_info <- ratios[colnames(counts),]
colnames(sample_info) <- colnames(sample_info) |>
  str_replace_all("`", "") |>
  str_replace_all(" ", "_")

sample_info$pct.change <- sample_info$pct.change |>
  str_replace_all("-", "_") |>
  as.factor()

sample_info$pct.change <- relevel(sample_info$pct.change, ref = "0")

TestModels <- function(model, para = FALSE){
# Create a DESeqDataSet
dds <- DESeqDataSetFromMatrix(
  countData = counts.small,
  colData = sample_info,
  design = model
)

# Run the DESeq pipeline
dds <- DESeq(dds, parallel = para)

# Run the differential expression analysis
resultsNames(dds)
genes <- lapply(pct.use, function(x)
{results(dds, contrast = c("pct.change", "0", x)) |> as.data.frame()})
return(genes)
}

pct.use <- levels(sample_info$pct.change)[-1]

#start <- Sys.time()
#de.lfcse <- lapply(models, function(x){TestModels(x)})  
#single.time <- Sys.time() - start

library(BiocParallel)
register(MulticoreParam(4))


start <- Sys.time()
deseq.res <- lapply(models, function(x){TestModels(x, para = T)})  
multi.time <- Sys.time() - start

#save(deseq.res, file = "jensen/results/benchmarking/deseq/08112023_2000g")

```



```{r get deseq data, fig.width= 11, fig.height= 6}


# Iterate over the names of de.lfcse
for (sublist_name in names(deseq.res)) {
  # Get the current sublist
  sublist <- deseq.res[[sublist_name]]
  
  # Rename the elements in the sublist using pct.use
  names(sublist) <- pct.use
  
  # Update the sublist in de.lfcse
  deseq.res[[sublist_name]] <- sublist
}


# Function to collect values from nested list DESeq output
calculate_stats <- function(data, column_name, threshold) {
  result <- data %>%
    enframe(name = "sublist_name", value = "data") %>%
    mutate(data = map(data, ~.x %>% enframe(name = "sub_sublist_name", value = "values"))) %>%
    unnest(data) %>%
    mutate(
      mean_value = map_dbl(values, ~mean(.x[[column_name]], na.rm = TRUE)),
      std_dev = map_dbl(values, ~sd(.x[[column_name]], na.rm = TRUE)),
      false_pos = map_dbl(values, ~sum(abs(.x[[column_name]]) < threshold, na.rm = TRUE))
    ) %>%
    select(-values)

  return(result)
}

result <- calculate_stats(deseq.res, "padj", 0.05)


result$sub_sublist_name <- result$sub_sublist_name |>
                     str_replace("_","-") |>
                     as.numeric()

result <- result |> 
      mutate(ModelType = factor(case_when(
      str_detect(sublist_name, "unadjusted") ~ "No adjustment",
      str_detect(sublist_name, "raw") ~ "Raw proportions",
      str_detect(sublist_name, "clr") ~ "Centered log ratios",
      str_detect(sub_sublist_name, "pc") ~ "PCA")))

```

```{r plot DESeq output}

pal <- c("#fa9fb5", "#f768a1", "#c51b8a", "#74c476", "#31a354", "#a6bddb", "#74a9cf", "#2b8cbe", "#969696")


result |>
ggplot(aes(x = sub_sublist_name, y = std_dev, color = sublist_name)) +
  geom_point(alpha = 0.8) + # smaller and more transparent points
  geom_smooth(se = F, method = "loess", size = 1.5, alpha = 0.5, span = 0.3) +
  #scale_y_continuous(trans = "log10") +
  scale_color_manual(values = pal) +
  theme_minimal() +
  theme(
    legend.position = c(0.9, 0.7),
    legend.title = element_blank(),
    text = element_text(size = 12),
    panel.grid.major = element_blank(), # remove major gridlines
    panel.grid.minor = element_blank()  # remove minor gridlines
  ) +
  labs(y= "Std dev of p-values", x = "General fibroblast proportion difference")

result |>
ggplot(aes(x = sub_sublist_name, y = mean_value, color = sublist_name)) +
  geom_point(alpha = 0.8) + # smaller and more transparent points
  geom_smooth(se = F, method = "loess", size = 1.5, alpha = 0.5, span = 0.3) +
  #scale_y_continuous(trans = "log2") +
  scale_color_manual(values = pal) +
  theme_minimal() +
  theme(
    legend.position = c(0.9, 0.7),
    legend.title = element_blank(),
    text = element_text(size = 12),
    panel.grid.major = element_blank(), # remove major gridlines
    panel.grid.minor = element_blank()  # remove minor gridlines
  ) +
  geom_magnify(from = c(-0.06,0.06,0.98,1), to = c(-0.19,-0.06,0.6,0.9), 
                   shape = "rect", shadow = TRUE)  +
  labs(y= "Mean p-value", x = "General fibroblast proportion difference") +
  ggtitle("Centered log ratio adjustments protect from compositionly caused low p-values")




pal <- c("#fa9fb5", "#f768a1", "#c51b8a", "#a6bddb", "#74a9cf", "#2b8cbe", "#969696")


result |>
  subset(ModelType != "PCA") |>
ggplot(aes(x = sub_sublist_name, y = false_pos +0.01, color = sublist_name)) +
  geom_point(alpha = 0.4) + # smaller and more transparent points
  geom_smooth(se = F, method = "loess", size = 1.5, alpha = 0.5, span = 0.2) +
  #scale_y_continuous(trans = "log2") +
  scale_color_manual(values = pal) +
  theme_minimal() +
  theme(
    legend.position = c(0.9, 0.4),
    legend.title = element_blank(),
    text = element_text(size = 12),
    panel.grid.major = element_blank(), # remove major gridlines
    panel.grid.minor = element_blank()  # remove minor gridlines
  ) +
  geom_magnify(from = c(-0.07, 0.07,0,35), to = c(-0.07,0.07, 300,600), 
                   shape = "rect", shadow = F)  +
  labs(y= "False Positives", x = "General fibroblast proportion difference") +
  ggtitle("Centered log ratio covariates minimize false positives from compositional differences")

```

