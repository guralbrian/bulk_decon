---
title: "PseudoBulk V2"
author: "Brian Gural"
date: "2023-08-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load libs, message=FALSE, echo = F, warning=FALSE, results= 'hide', cache=FALSE, include=F}
# List libraries
libs <- c("Seurat", "ggplot2", "patchwork", "SeuratDisk","reshape2", "tidyverse",
          "SCpubr","shiny", "ggrepel", "gridExtra", "scCustomize", "httr", 
          "scales", "dplyr", "DeconvoBuddies", "readr", "SingleCellExperiment",
          "SummarizedExperiment", "Biobase", "ggmagnify", "stringr", "MuSiC",
          "ggforce", "DirichletReg", "readxl", "viridis", "DESeq2") # list libraries here
# Require all of them
lapply(libs, require, character.only = T)

# Also load in-house functions
source("jensen/scripts/functions/decon_all.R")
```

```{r load data, cache = TRUE, echo=FALSE, message=F, include = F}
sn <- LoadH5Seurat("jensen/data/processed/single_cell/merged_datasets/07192023/07192023_1.h5seurat")
```
## R Markdown

Having highly correlated variables in the design leads to unstable estimates of coefficients which will be reflected in large standard errors - Mike Love

This Rmd is meant to test the effect of different representations of composition in DESeq2 models. I've made simulated bulk RNAseq datasets of from range of cell type proportions, using snRNAseq as a gene expression profile reference. The null hypothesis is that compositional differences will not result in false positives between samples. The alternative hypothesis is that there will be differences and the can be accounted for with covariates which represent the composition.


```{r cell profiles, include=F}

# Sum expression of each cell type cluster in the seurat
GetCellProfile <- function(seurat, cell.type){
  cell.ids  <- Idents(seurat)[which(Idents(seurat) == cell.type)] |>
    names() # Get the cell.ids that are the cell type of interest
  cell.type.profile <- rowSums(seurat@assays$RNA@counts[,cell.ids]) |>
    as.numeric()  # sum expression of cells with those ids
  assign(as.character(cell.type), cell.type.profile) # name the profile with the cell type
  return(get(as.character(cell.type)))
}


cell.types <- unique(Idents(sn))
# Make matrix of expression profiles 
# Each col should be a cell type
# Each row should be a gene
cell.expr.prof <- sapply(cell.types, function(x){GetCellProfile(sn, x)}, USE.NAMES = T)
colnames(cell.expr.prof) <- cell.types
row.names(cell.expr.prof) <- row.names(sn) 


# This defines the probability of which gene a single UMI will be, by cell type
# each cell will contain the probability of a random UMI from that cell type/column to be that gene/row
# Could be simultaneous with prior step
gene.probs <- sweep(cell.expr.prof,2,colSums(cell.expr.prof),`/`) |>
              as.data.frame()

```

```{r make pb functions, include = F}

# Make function to take in a named list of proportions, then multiply by the ratio
# then multiply it all by umi target
# then add noise
# then round to integers

MakePseudoBulk <- function(ratios, profiles, umi_target, noise) {
  ratio.format <- as.vector(ratios)
  names(ratio.format) <- names(ratios)
  # Ensure ratios is a named list or named vector
  if (!is.list(ratio.format) && !is.vector(ratio.format)) {
    stop("ratios must be a named list or named vector")
  }
  if (!all(names(ratio.format) %in% colnames(profiles))) {
    stop("All names in ratios must be present as columns in profiles")
  }

  # Modify columns by multiplying with ratios and adding noise
  profiles.use <- profiles |>
    select(all_of(names(ratio.format))) |>
    mutate(across(all_of(names(ratio.format)), 
                  ~ jitter(.x * ratio.format[[as.character(cur_column())]], factor = noise)))
    #rnorm(n()) adds Gaussian noise to each column. Generates random numbers from a normal distribution with a standard deviation of noise.
  profiles.use[profiles.use < 0 ] <- 0
  # Compute mean of all columns
  mean_column <- profiles.use |>
    rowMeans()

  # Normalize the result to sum to 1
  mean_column_norm <- mean_column / sum(mean_column)
  counts <- mean_column_norm * umi_target
  counts <- counts |>
    round() |>
    as.integer()
  
  names(counts) <- row.names(profiles)
  
  return(counts)
}


# Function to make a data frame of cell type ratios
simulate_ratios <- function(major_cell, changing_cell, major_prop, changing_prop, 
                            cell_types, range, step_size, n, changing_range, major_range,
                            immune_norm
                            ) {
  # get values for major cell type
  major_props <- sample(seq(major_prop - major_range, major_prop + major_range, 0.0001), n, replace = T)
  
  # get values for changing cell type
  changing_props <- sample(seq(changing_prop - changing_range, changing_prop + changing_range, 0.0001), n, replace = T) 
  # Set major cell type and proportion
  minor <- cell_types[!(cell_types %in% c(major_cell, changing_cell))]
  
  
  # Define the range for proportions
  minor_props <- rep((1-major_props-changing_props)/length(minor), length(minor)) |>
                 matrix(ncol = length(minor)) |>
                 as.data.frame()
  colnames(minor_props) <- minor

  combos <- c(major_props, changing_props) |>
            matrix(ncol = 2) |>
            as.data.frame()
  colnames(combos) <- c(major_cell, changing_cell)
  
  props <- cbind(combos, minor_props)
  props$pct.change <- changing_props - changing_prop
  rownames(props) <- paste0("mix_", 1:nrow(props))
  
  props[,3] <- props[,3] * sample(rnorm(1000, immune_norm, 0.01), 1000)
  props[,4] <- props[,4] * sample(rnorm(1000, 1, 0.01), 1000)
  
  props[,1:5]  <- props[,1:5]/rowSums(props[,1:5])
  
  return(props)
}



```

```{r make pb ratios}

major.cell <- "cardiomyocytes"
changing.cell <- "fibroblasts"
major.prop <- 0.75
changing.prop <- 0.1
changing_range = 0.08
immune_norm <- 1
major_range = 0.08
n = 100

healthy.ratios <- simulate_ratios(major_cell = major.cell, changing_cell = changing.cell, 
                major_prop = major.prop, changing_prop = changing.prop, 
                cell_types = cell.types, range = range, step_size = step.size, n = n,
                major_range = major_range, changing_range = changing_range,
                immune_norm = immune_norm)

rownames(healthy.ratios) <- paste0(rownames(healthy.ratios), "_heal")

major.cell <- "cardiomyocytes"
changing.cell <- "fibroblasts"
major.prop <- 0.65
changing.prop <- 0.18
changing_range = 0.04
major_range = 0.04
immune_norm <- 1.5
n = 100

sick.ratios <- simulate_ratios(major_cell = major.cell, changing_cell = changing.cell, 
                major_prop = major.prop, changing_prop = changing.prop, 
                cell_types = cell.types, range = range, step_size = step.size, n = n,
                major_range = major_range, changing_range = changing_range, 
                immune_norm = immune_norm)
rownames(sick.ratios) <- paste0(rownames(sick.ratios), "_sick")

```


```{r make pseudobulk}
# Function to make a list of cell type ratios
umi.target <- 3*10^7
# take each row of cell.ratios and put it into MakePseudoBulk 
pb.heal <- sapply(1:nrow(healthy.ratios), function(x){MakePseudoBulk(healthy.ratios[x,-6], gene.probs, umi.target, 10)}) |>
   as.data.frame()
colnames(pb.heal) <- rownames(healthy.ratios)
healthy.ratios$status <- "healthy"
```

```{r make pseudobulk sick}
# Function to make a list of cell type ratios
umi.target <- 3*10^7
# take each row of cell.ratios and put it into MakePseudoBulk 
pb.sick <- sapply(1:nrow(sick.ratios), function(x){MakePseudoBulk(sick.ratios[x,-6], gene.probs, umi.target, 10)}) |>
   as.data.frame()
colnames(pb.sick) <- rownames(sick.ratios)
sick.ratios$status <- "sick"
```


```{r merge pb}
pb.comps <- cbind(pb.heal, pb.sick)

ratios <- rbind(sick.ratios, healthy.ratios)
# add sample ids as a column

cell.ratios$id <- rownames(cell.ratios)

```

```{r comp vars prep}
# Make clr comp
library(compositions)
clr.sample <- clr(ratios[,as.character(cell.types)])
colnames(clr.sample) <- paste0("clr.", colnames(clr.sample))

# Make PCA comp
pca.sample <- prcomp(t(ratios[,as.character(cell.types)]))$rotation |>
              as.data.frame()

pca.sample$status <- ratios$status
pca.sample$fb <- ratios$fibroblasts
pca.sample$cm <- ratios$cardiomyocytes

ggplot(pca.sample, aes(x = PC1, y = PC2, color = cm, size = fb)) +
  geom_point()


# add this info back to proportion dfs 
ratios <- cbind(ratios, clr.sample) |>
                 cbind(pca.sample)

```


```{r make deseq2 df }
# make df with clr, pca, and raw compositions
counts <- pb.comps 
counts.small <- counts[sample(rownames(counts), 1000),]
```

```{r deseq2 model comparison improvement}

models <- list(
  no_composition  = ~ status,
  raw_composition = ~ status + cardiomyocytes + fibroblasts,
  clr_composition = ~ status + clr.cardiomyocytes + clr.fibroblasts,
  pca_composition = ~ status + PC1 + PC2 
)

```

```{r deseq prep}
# Prepare sample information
sample_info <- ratios[colnames(counts),]


dds <- DESeqDataSetFromMatrix(
  countData = counts.small,
  colData = sample_info,
  design = models
)
lapply()
dds <- DESeq(dds)
dds.raw <- results(dds, name = resultsNames(dds)[2]) |>
                subset(padj < 0.05) |>
                nrow() |>
                unlist()
```

```{r old deseq function}
TestModels <- function(model){
# Create a DESeqDataSet
dds <- DESeqDataSetFromMatrix(
  countData = counts.small,
  colData = sample_info,
  design = model
)

# Run the DESeq pipeline
dds <- DESeq(dds)

# Run the differential expression analysis

genes  <- results(dds, name = resultsNames(dds)[2]) |>
                subset(padj < 0.05) |>
                nrow() |>
                unlist()
return(genes)
}


lapply(models, function(x){TestModels(x)})

```

```{r paralellized DESeq2}
library(BiocParallel)

counts <- counts[,rownames(sample_info)]
start <- Sys.time()
results <- lapply(models, function(x){TestModels(x)})
end <- start - Sys.time()

```


```{r apply for deseq, include = F}

all_combinations <- expand.grid(pct.diff = unique(ratios.sample$pct.diff)[unique(ratios.sample$pct.diff)!= 0],
                                major.type = unique(ratios.sample$major.type)[!is.na(unique(ratios.sample$major.type))])
ratios.checklist <- paste(ratios.sample$pct.diff, ratios.sample$major.type, sep = "_")

real.comb <- all_combinations |>
             mutate(checklist = paste(pct.diff, major.type, sep = "_")) |>
             subset(checklist %in% ratios.checklist) |>
             select(pct.diff, major.type)

# The function to be applied for each combination
perform_analysis <- function(pct_diff, major_type) {
  cur.ratios <- ratios.sample |>
              subset(major.type == major_type) |>
              subset(pct.diff == pct_diff)
  
  cur.pb <- pb.comps %>% 
            as.data.frame() %>% 
            select(cur.ratios$id)
  
  merge.ratios <- rbind(cell.ratios.ref, cur.ratios)
  merge.pb <- cbind(pb.refs, cur.pb)

  sample_info <- data.frame(
    row.names = colnames(merge.pb),
    group = as.factor(merge.ratios$pct.diff)
  )

  dds <- DESeqDataSetFromMatrix(
    countData = merge.pb,
    colData = sample_info,
    design = ~ group
  )

  dds <- DESeq(dds)
  res <- results(dds, name = resultsNames(dds)[2])
  
  sig.genes <- res %>%
               subset(padj < 0.01) %>%
               nrow()
  
  return(sig.genes)
}
start <- Sys.time()
results <- mapply(perform_analysis, 
                 pct_diff = real.comb$pct.diff, 
                 major_type = real.comb$major.type)

names(results) <- apply(real.comb, 1, paste, collapse = "-")
Sys.time() - start
```
```{r process deseq results}
# Extract numbers and cell names
numbers <- gsub("-.*$", "", names(results))
cell_names <- lapply(str_split(names(results), "-"), "[[", 2) |>
              unlist()

# Create a data frame
false_pos <- data.frame(
  pct.diff = numbers,
  CellName = cell_names,
  Value = unname(results)
)

# Reshape the data frame
false_pos <- false_pos %>%
  spread(key = CellName, value = Value)

# Use Number as rownames
rownames(false_pos) <- false_pos$pct.diff

de_melt <- melt(false_pos, id.vars = "pct.diff") |>
           na.omit()

```

```{r plot false positives}

ggplot(data = de_melt, aes(x = pct.diff, y = value, color = variable)) +
  geom_point() + 
  geom_smooth(method = "lm")


```

```{r comp vars prep}
# Make clr comp
library(compositions)
comps.clr <- clr(ratios.sample[4:ncol(ratios.sample)])
colnames(comps.clr) <- paste0("clr.", colnames(comps.clr))


# Make PCA comp
pca.sample <- prcomp(t(rbind(ratios.sample[4:ncol(ratios.sample)], cell.ratios.ref[1:5])))

pca.ref <- pca.sample$rotation[rownames(cell.ratios.ref),]
pca.sample <- pca.sample$rotation[rownames(ratios.sample),]
```



```{r pre deseq clr}
sample.pca <- cbind(ratios.sample, pca.sample)
ref.pca <- cbind(cell.ratios.ref, pca.ref)

ref.pca$pct.diff <- 0
# Create a DESeqDataSet
dds.pca <- DESeqDataSetFromMatrix(
  countData = count_data,
  colData = sample.pca,
  design = ~ genotype + treatment + genotype:treatment + PC1 
)

# Run the DESeq pipeline
dds.pca <- DESeq(dds.pca)

# Run the differential expression analysis
res.pca <- results(dds.pca, name="genotypeKO.treatmentMI")

```



```{r clr deseq}
# The function to be applied for each combination
deseq_pca <- function(pct_diff, major_type) {
   major_type <-  real.comb$major.type[1]
   
   cur.ratios <- sample.pca |>
              subset(major.type == major_type)
   
  cur.pb <- pb.comps %>% 
            as.data.frame() %>% 
            select(cur.ratios$id)
  cur.ratios$type <- "test"
  ref.pca$type <- "ref"
  merge.ratios <- rbind(ref.pca, cur.ratios)
  merge.pb <- cbind(pb.refs, cur.pb)

  sample_info <- data.frame(
    row.names = colnames(merge.pb),
    pct.diff = as.numeric(merge.ratios$pct.diff),
    type = as.factor(merge.ratios$type)
  )
  sample_info <- cbind(sample_info, merge.ratios[,colnames(pca.sample)])

  dds <- DESeqDataSetFromMatrix(
    countData = merge.pb,
    colData = sample_info,
    design = ~ type 
  )

  dds <- DESeq(dds)
  res <- results(dds, name = resultsNames(dds)[2])
  
  sig.genes <- res %>%
               subset(padj < 0.01) %>%
               nrow()
  
  dds <- DESeqDataSetFromMatrix(
    countData = merge.pb,
    colData = sample_info,
    design = ~ type + PC1
  )

  dds <- DESeq(dds)
  res <- results(dds, name = resultsNames(dds)[2])
  
  sig.genes.pca <- res %>%
               subset(padj < 0.01) %>%
               nrow()
  genes.df <- data.frame(pca = sig.genes.pca,
                         no_pca = sig.genes)
  
  return(sig.genes)
}
start <- Sys.time()
results <- mapply(deseq_clr, 
                 pct_diff = real.comb$pct.diff, 
                 major_type = real.comb$major.type)

names(results) <- apply(real.comb, 1, paste, collapse = "-")
Sys.time() - start
```

```{r make mega df }
# make df with clr, pca, and raw compositions


```

```{r deseq2 model comparison improvement}

models <- list(
  no_composition = ~ group,
  raw_composition = ~ group + raw_composition,
  clr_composition = ~ group + clr_composition,
  pca_composition = ~ group + PCA1  # assuming two principal components, adjust accordingly
)

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
