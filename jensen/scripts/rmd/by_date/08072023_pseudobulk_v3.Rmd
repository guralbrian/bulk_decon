---
title: "PseudoBulk V2"
author: "Brian Gural"
date: "2023-08-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load libs, message=FALSE, echo = F, warning=FALSE, results= 'hide', cache=FALSE, include=F}
# List libraries
libs <- c("Seurat", "ggplot2", "patchwork", "SeuratDisk","reshape2", "tidyverse",
          "SCpubr","shiny", "ggrepel", "gridExtra", "scCustomize", "httr", 
          "scales", "dplyr", "DeconvoBuddies", "readr", "SingleCellExperiment",
          "SummarizedExperiment", "Biobase", "ggmagnify", "stringr", "MuSiC",
          "ggforce", "DirichletReg", "readxl", "viridis", "DESeq2", "rlist") # list libraries here
# Require all of them
lapply(libs, require, character.only = T)

# Also load in-house functions
source("jensen/scripts/functions/decon_all.R")
```

```{r load data, cache = TRUE, echo=FALSE, message=F, include = F}
sn <- LoadH5Seurat("jensen/data/processed/single_cell/merged_datasets/07192023/07192023_1.h5seurat")
```
## R Markdown

Having highly correlated variables in the design leads to unstable estimates of coefficients which will be reflected in large standard errors - Mike Love

This Rmd is meant to test the effect of different representations of composition in DESeq2 models. I've made simulated bulk RNAseq datasets of from range of cell type proportions, using snRNAseq as a gene expression profile reference. The null hypothesis is that compositional differences will not result in false positives between samples. The alternative hypothesis is that there will be differences and the can be accounted for with covariates which represent the composition.


```{r cell profiles, include=F}

# Sum expression of each cell type cluster in the seurat
GetCellProfile <- function(seurat, cell.type){
  cell.ids  <- Idents(seurat)[which(Idents(seurat) == cell.type)] |>
    names() # Get the cell.ids that are the cell type of interest
  cell.type.profile <- rowSums(seurat@assays$RNA@counts[,cell.ids]) |>
    as.numeric()  # sum expression of cells with those ids
  assign(as.character(cell.type), cell.type.profile) # name the profile with the cell type
  return(get(as.character(cell.type)))
}


cell.types <- unique(Idents(sn))
# Make matrix of expression profiles 
# Each col should be a cell type
# Each row should be a gene
cell.expr.prof <- sapply(cell.types, function(x){GetCellProfile(sn, x)}, USE.NAMES = T)
colnames(cell.expr.prof) <- cell.types
row.names(cell.expr.prof) <- row.names(sn) 


# This defines the probability of which gene a single UMI will be, by cell type
# each cell will contain the probability of a random UMI from that cell type/column to be that gene/row
# Could be simultaneous with prior step
gene.probs <- sweep(cell.expr.prof,2,colSums(cell.expr.prof),`/`) |>
              as.data.frame()

```

```{r make pb functions, include = F}

# Make function to take in a named list of proportions, then multiply by the ratio
# then multiply it all by umi target
# then add noise
# then round to integers

MakePseudoBulk <- function(ratios, profiles, umi_target, noise) {
  ratio.format <- as.vector(ratios)
  names(ratio.format) <- names(ratios)
  # Ensure ratios is a named list or named vector
  if (!is.list(ratio.format) && !is.vector(ratio.format)) {
    stop("ratios must be a named list or named vector")
  }
  if (!all(names(ratio.format) %in% colnames(profiles))) {
    stop("All names in ratios must be present as columns in profiles")
  }

  # Modify columns by multiplying with ratios and adding noise
  profiles.use <- profiles |>
    select(all_of(names(ratio.format))) |>
    mutate(across(all_of(names(ratio.format)), 
                  ~ jitter(.x * ratio.format[[as.character(cur_column())]], factor = noise)))
    #rnorm(n()) adds Gaussian noise to each column. Generates random numbers from a normal distribution with a standard deviation of noise.
  profiles.use[profiles.use < 0 ] <- 0
  # Compute mean of all columns
  mean_column <- profiles.use |>
    rowMeans()

  # Normalize the result to sum to 1
  mean_column_norm <- mean_column / sum(mean_column)
  counts <- mean_column_norm * umi_target
  counts <- counts |>
    round() |>
    as.integer()
  
  names(counts) <- row.names(profiles)
  
  return(counts)
}


# Function to make a data frame of cell type ratios
simulate_ratios <- function(major_cell, changing_cell, major_prop, changing_prop, 
                            cell_types, range, step_size, replicates, noise) {
  
  # get group tiers for major cell type
  # these are the percentages of the major cell type for which groups will be centered
  major_props_groups <- seq(major_prop - range, major_prop + range, step_size)
  
  # get values for major cell type
  # each value in the major_props_groups vector is used as a mean with n replicates pulled from a normal distribution with noise
  major_props <- lapply(major_props_groups, function(x){rnorm(replicates, x, noise)}) |>
                   unlist()
  
  # get group tiers for changing cell type
  changing_props_groups <- rev(seq(changing_prop - range, changing_prop + range, step_size))
  
  #get values for changing cell type
  changing_props <- lapply(changing_props_groups, function(x){rnorm(replicates, x, noise)}) |>
                      unlist()
  
  # Set major cell type and proportion
  minor <- cell_types[!(cell_types %in% c(major_cell, changing_cell))]
  
  
  # Define the range for proportions
  minor_props <- rep((1-major_props-changing_props)/length(minor), length(minor)) |>
                 matrix(ncol = length(minor)) |>
                 as.data.frame()
  colnames(minor_props) <- minor
  
  # set up props dataframe
  combos <- c(major_props, changing_props) |>
            matrix(ncol = 2) |>
            as.data.frame()
  colnames(combos) <- c(major_cell, changing_cell)
  
  # add minor cell types to props data frame
  props <- cbind(combos, minor_props)
  props$pct.change <- as.factor(rep(changing_props_groups - changing_prop, each = replicates))
  props$pct.change <- relevel(props$pct.change, ref = "0")
  rownames(props) <- paste0("mix_", 1:nrow(props))
  
  # add 3rd and 4th cell type proportions with a very small amount of noise
  props[,3] <- props[,3] * sample(rnorm(1000, 1, 0.01), length(changing_props))
  props[,4] <- props[,4] * sample(rnorm(1000, 1, 0.003), length(changing_props))
  
  # Normalize back to proportional sum == 1
  props[,1:5]  <- props[,1:5]/rowSums(props[,1:5])
  
  return(props)
}


# Function to sample cell IDs from a cell type, then aggregate their expression
AddCellProfile <- function(sn, count, cell_type){
    
    # Get the cell.ids that are the cell type of interest
    cell.ids  <- Idents(sn)[which(Idents(sn) == cell_type)] |>
              names() |>
              sample(size = count[cell_type], replace = T)
 
     # sum expression of cells with those ids
     cell.type.profile <- rowSums(sn@assays$RNA@counts[,cell.ids]) |>
       as.numeric()  
     assign(as.character(cell_type), cell.type.profile) # name the profile with the cell type
    return(get(as.character(cell_type)))
  }
  
AggCells <- function(sn, ratios, cell_count) {
  
  ratio.format <- ratios[1,] |> unlist()
  names(ratio.format) <- names(ratios)
  # Ensure ratios is a named list or named vector
  if (!is.list(ratio.format) && !is.vector(ratio.format)) {
    stop("ratios must be a named list or named vector")
  }
  # Cell counts by type
  cell_counts <- round(ratio.format * cell_count)
  #names(cell_counts) <- seq(0,length(ratio.format)-1, 1)
  dat <- sapply(1:length(cell_counts), function(x)
            {
            AddCellProfile(sn, cell_counts[x], names(cell_counts)[x])
            }
               ) |>
            rowSums()
  names(dat) <- rownames(sn)
  return(dat)
}


```


```{r make pb ratios}

major.cell <- "cardiomyocytes"
changing.cell <- "fibroblasts"
major.prop <- 0.5
changing.prop <- 0.25
range <- 0.22
step.size <- 0.01
replicates <- 3
noise <- 0.005

ratios <- simulate_ratios(major_cell = major.cell, 
                                  changing_cell = changing.cell, 
                                  major_prop = major.prop, 
                                  changing_prop = changing.prop, 
                                  cell_types = cell.types, 
                                  range = range, 
                                  step_size = step.size, 
                                  replicates = replicates,
                                  noise = noise)

```

```{r make  pseudobulk}
# Function to make a list of cell type ratios
umi.target <- 3*10^7
# take each row of cell.ratios and put it into MakePseudoBulk 
pb <- sapply(1:nrow(ratios), function(x){MakePseudoBulk(ratios[x,-6], gene.probs, umi.target, 3)}) |>
   as.data.frame()
colnames(pb) <- rownames(ratios)
```

```{r make additive pseudobulk}
start <- Sys.time()
# Function to make a list of cell type ratios
cell.target <- 10000
# take each row of cell.ratios and put it into MakePseudoBulk 
pb.add <- sapply(1:nrow(ratios), function(x){AggCells(sn, ratios[x,-6], cell.target)}) |>
      as.data.frame()
colnames(pb.add) <- rownames(ratios)

end <- Sys.time() - start
```


```{r comp vars prep}
# Make clr comp
library(compositions)
clr.sample <- clr(ratios[,as.character(cell.types)])
colnames(clr.sample) <- paste0("clr.", colnames(clr.sample))

# Make PCA comp
pca.sample <- prcomp(t(ratios[,as.character(cell.types)]))$rotation |>
              as.data.frame()

pca.sample$pct.change <- ratios$pct.change
pca.sample$fb <- ratios$fibroblasts
pca.sample$cm <- ratios$cardiomyocytes

ggplot(pca.sample, aes(x = PC1, y = PC2, color = pct.change, size = fb)) +
  geom_point()


# add this info back to proportion dfs 
ratios <- cbind(ratios, clr.sample) |> 
                 cbind(pca.sample) 

pca.rna <- prcomp(pb.add)$rotation |>
           as.data.frame()

pca.rna$pct.change <- ratios$pct.change
pca.rna$fb <- ratios$fibroblasts
pca.rna$cm <- ratios$cardiomyocytes


ggplot(pca.rna, aes(x = PC1, y = PC2, color = cm, size = fb)) +
  geom_point()
```


```{r make deseq2 df }
# make df with clr, pca, and raw compositions
counts <- pb.add
counts.small <- counts[sample(rownames(counts), 500),]
```

```{r deseq2 model comparison improvement}

models <- list(
  unadjusted    = ~ 0 + pct.change,
  raw_cm        = ~ 0 + pct.change + cardiomyocytes,
  raw_cm_fb     = ~ 0 + pct.change + cardiomyocytes + fibroblasts,
  #raw_cm_fb_im  = ~ 0 + pct.change + cardiomyocytes + fibroblasts + immune,
  clr_cm        = ~ 0 + pct.change + clr.cardiomyocytes,
  clr_cm_fb     = ~ 0 + pct.change + clr.cardiomyocytes + clr.fibroblasts
  #clr_cm_fb_im  = ~ 0 + pct.change + clr.cardiomyocytes + clr.fibroblasts + clr.immune,
  #pc1           = ~ 0 + pct.change + PC1,
  #pc1_2         = ~ 0 + pct.change + PC1 + PC2
)


```

```{r old deseq function, include = F}

sample_info <- ratios[colnames(counts),]
colnames(sample_info) <- colnames(sample_info) |>
  str_replace_all("`", "") |>
  str_replace_all(" ", "_")

sample_info$pct.change <- sample_info$pct.change |>
  str_replace_all("-", "_") |>
  as.factor()

sample_info$pct.change <- relevel(sample_info$pct.change, ref = "0")

TestModels <- function(model){
# Create a DESeqDataSet
dds <- DESeqDataSetFromMatrix(
  countData = counts.small,
  colData = sample_info,
  design = model
)

# Run the DESeq pipeline
dds <- DESeq(dds)

# Run the differential expression analysis
resultsNames(dds)
genes <- lapply(pct.use, function(x)
{results(dds, contrast = c("pct.change", "0", x)) |> subset(padj < 0.05) |> as.data.frame() |> pull(lfcSE)})
return(genes)
}

pct.use <- levels(sample_info$pct.change)[-1]

test.fib <- lapply(models, function(x){TestModels(x)})  

#write.csv(test.fib, "jensen/results/benchmarking/deseq/08092023_2000g")
```

```{r get logfcSE}
library(purrr)
library(dplyr)

# Function to calculate length and mean of each sub sub list
extract_values <- function(sub_list_name, sub_sub_list) {
  tibble(
    sub_list = sub_list_name,
    length = length(sub_sub_list),
    mean_value = mean(unlist(sub_sub_list), na.rm = TRUE)
  )
}

# Function to process sub lists
process_sub_list <- function(sub_list_name, sub_list) {
  map_df(seq_along(sub_list), ~ extract_values(sub_list_name, sub_list[[.]]))
}

# Apply the function to the entire nested list
result <- map2_df(names(test.fib), test.fib, process_sub_list)
result$pct.change <- pct.use |>
                     str_replace("_","-") |>
                     as.numeric() |>
                     rep(length(models))


```

```{r get logfcSE, fig.width= 12, fig.height= 7}

se.res <- melt(result, id.vars = c("pct.change", "sub_list", "mean_value"))

se.res$NumberCovariates <- rep(c(0,1,2,1,2), each = outs) 

se.res$Model <- rep(as.character(models), each = outs) 

se.res$


se.res <- se.res |> 
      mutate(ModelType = factor(case_when(
      str_detect(variable, "unadjusted") ~ "No adjustment",
      str_detect(variable, "raw") ~ "Raw proportions",
      str_detect(variable, "clr") ~ "Centered log ratios")))

pal <- c("#969696", "#fa9fb5", "#f768a1", "#a6bddb", "#74a9cf")

se.res |>
ggplot(aes(x = pct.change, y = mean_value, color = Model)) +
  geom_point(alpha = 0.8) + # smaller and more transparent points
  geom_smooth(se = F, method = "loess", size = 1.5, alpha = 0.7) +
  scale_color_manual(values = pal) +
  theme_minimal() +
  theme(
    legend.title = element_blank(),
    legend.position = "left",
    text = element_text(size = 12),
    panel.grid.major = element_blank(), # remove major gridlines
    panel.grid.minor = element_blank()  # remove minor gridlines
  ) +
  labs(y= "Average logfc SE of false postives", x = "General fibroblast proportion difference")
```

```{r plot deseq2 res, fig.width= 12, fig.height= 7}

plot.genes <- read.csv("jensen/results/benchmarking/deseq/08092023_2000g", row.names = 1)
outs <- nrow(plot.genes)


plot.genes$pct.changed <- as.numeric(pct.use)


plot.genes <- melt(plot.genes, id.vars = c("pct.changed"))

plot.genes$NumberCovariates <- rep(c(0,1,2,3,1,2,3,1,2), each = outs) 

plot.genes$Model <- rep(as.character(models), each = outs) 



plot.genes <- plot.genes |> 
      mutate(ModelType = factor(case_when(
      str_detect(variable, "unadjusted") ~ "No adjustment",
      str_detect(variable, "pc") ~ "PCA",
      str_detect(variable, "raw") ~ "Raw proportions",
      str_detect(variable, "clr") ~ "Centered log ratios")))

pal <- c("#969696", "#fcc5c0", "#fa9fb5", "#f768a1", "#d0d1e6", "#a6bddb", "#74a9cf", "#feb24c","#fd8d3c")

plot.genes |>
ggplot(aes(x = pct.changed, y = value/3, color = Model)) +
  geom_point(alpha = 0.5) + # smaller and more transparent points
  geom_smooth(se = F, method = "loess", size = 1.5, span = 0.45, alpha = 0.7) +
  scale_y_continuous(trans = "log10", 
                     breaks = scales::trans_breaks("log10", function(x) 10^x, n = 3), # fewer y axis labels
                     labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_manual(values = pal) +
  theme_minimal() +
  theme(
    legend.title = element_blank(),
    legend.position = "left",
    text = element_text(size = 12),
    panel.grid.major = element_blank(), # remove major gridlines
    panel.grid.minor = element_blank()  # remove minor gridlines
  ) +
  labs(y= "False Postives", x = "General fibroblast proportion difference")

```

