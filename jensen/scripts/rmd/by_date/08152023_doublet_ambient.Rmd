---
title: "Remove doublets and ambient RNA"
author: "Brian Gural"
date: "2023-08-15"
output: html_document
  code_folding: hide
code_download: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width = 8, message = F, warning = F)
```

# Introduction

## Rational

This script is meant to remove single cell doublets and ambient RNA from a snRNAseq dataset produced by Christoph Rau. Each sample is the aggregate of 5 samples, all male B6 mice.

## Pipeline overview

### Main methods

This pipeline makes use of the DropletUtils package to remove ambient RNA and scDblFinder to score droplets on their likelihood of containing more than one nuclei. Here, we are generally following a combination of pipelines. The first two are by BioConductor for [droplet processing] (http://bioconductor.org/books/3.14/OSCA.advanced/droplet-processing.html) and [quality control of PBMC data](http://bioconductor.org/books/3.14/OSCA.workflows/unfiltered-human-pbmcs-10x-genomics.html#unfiltered-human-pbmcs-10x-genomics)

### Step-by-step

The general structure of this analysis is as follows:
- Load all data and packages
- Trim down size of single cell datasets
  - They have > 1.7 million droplets, so exclude most of the nearly empty ones
- Identify empty droplets
  - Involves ranking droplets by counts, QC/clustering, looking for an empty droplet cluster (defined by low counts and high homogeneity)
- Regress empty droplet cluster expression profile from all other clusters
  - We'll also take a look at how this affected expression of canonical markers
- Identify doublets by simulating our own doublets, clustering, and checking for overlaps
  - Plus visualizing doublets scores
- Save all of the data as a Seurat


# Analysis

## Load data/packages

```{r load libs, message=FALSE, echo = T, warning=FALSE, results= 'hide', cache=FALSE, include=F}
# List libraries
libs <- c("Seurat", "ggplot2", "patchwork","SeuratDisk", "reshape2",
          "tidyverse", "SingleCellExperiment", "viridis", "gplots", "scales", 
          "ggrepel", "gridExtra", "scCustomize", "matrixStats", "scran", 
          "scuttle", "scater", "DropletUtils", "scDblFinder", "scuttle", "BiocParallel") # list libraries here
# Require all of them
lapply(libs, require, character.only = T)
rm(libs)
```


```{r load data, message=FALSE, echo = T, warning = FALSE, cache = T, include=F, collapse = T}
dir <- "jensen/data/raw/single_cell/patterson/seurat/"
files <- paste0(dir, list.files(dir))
# Function to load data
.loadData <- function(file_path) {
  sn <- LoadH5Seurat(file_path)
  sn <- subset(sn, nCount_RNA > 0)
  sn$UMI <- colnames(sn)
  return(sn)
}

sn <- lapply(files, function(x){.loadData(x)})
```
 
## Remove excess of empty droplets

I didn't want to include all of the >700K droplets which had <5 counts, but I didn't want to completely exclude them. I compromised selecting for droplets with > 300 counts and then sampling 10K of the rest. This left me with ~29K and ~37K droplets in each sample going forward.

```{r subset empty drops}

# Function to subset empty drops
.subsetEmptyDrops <- function(sn) {
  empty.drops <- sn %>%
                 subset(nCount_RNA <= 300) # too many empty droplets to process
  empty.subset <- sample(colnames(empty.drops), 10000)
  keep.drops <- sn %>%
                subset(nCount_RNA > 300 | UMI %in% empty.subset) # add in a fraction of the empty droplets
  return(keep.drops)
}

sn <- lapply(sn, function(x){.subsetEmptyDrops(x)})

```

## Find empty droplets

This plot orders all of the droplets included in the subset and then plots their total RNA counts on the y-axis. It's meant to identify an 'elbow' in the data, which indicates a transition cell-containing droplets to empty droplets. However, our data has two inflection points. Using the lower limit maintained so many cells that it was impossible compute. My SLURM job ran out of memory (32 GB), after 11 hours. Now, with the higher threshold, memory usage stays <7 GB and the whole script runs in under half an hour.

```{r plot gene ranks}

# make sce object for later functions
sce <- lapply(sn, function(x){as.SingleCellExperiment(x)})
  
# rank each cell by the # counts
bcrank <-  lapply(sce, function(x){barcodeRanks(counts(x))})
    
# Function to plot each cell by the number of reads
# Looks for an inflection point
# We can assume that below the inflection point are empty droplets
# Weirdly there are two, so I went with the higher
 .plotRank <- function(ranks){
  uniq <- !duplicated(ranks$rank)
    o <- order(ranks$rank)
  # plot the ranks with the counts, look for the knee and inflection points
  plot(x = ranks$rank[uniq], y = ranks$total[uniq], log="y", xlab="Rank", ylab="Total UMI count", cex.lab=1.2) +
          lines(ranks$rank[o], ranks$fitted[o], col="red") +
          abline(h=metadata(ranks)$inflection, col="darkgreen", lty=2) +
          abline(h=metadata(ranks)$knee, col="dodgerblue", lty=2) +
          abline(h=500, col="darkorange", lty=2) 
          legend("bottomleft", legend=c("Inflection", "Knee", "Limit"), col=c("darkgreen", "dodgerblue", "darkorange"), lty=2, cex=1.2)
 }
 
bcrank.plots <-  lapply(bcrank, function(x){.plotRank(x)})

```

## Select empty droplets 

```{r emptyDrops limited}
# Test for empty droplets, assume those below the limit are empty
e.out <- lapply(sce, function(x){emptyDrops(x, test.ambient = T, lower = 500)})
```

## Standard scRNAseq QC pipeline

The ambient RNA detection relies on clustering the empty droplets. It works best with a proper processing pipeline, so that's what we're doing here.

```{r QC}
# limit to droplets lower than the false discovery threshold 
.qualityControl <- function(sce.func, e.out.funct) {
  sce.func <- sce.func[,which(e.out.funct$FDR <= 0.01)]
  is.mito <- grep("^mt-", rownames(sce.func))
  qc <- perCellQCMetrics(sce.func, subsets=list(MT=is.mito))
  discard.mito <- isOutlier(qc$subsets_MT_percent, type="higher")
  colData(sce.func) <- cbind(colData(sce.func), qc)
  sce.func <- sce.func[,!discard.mito]
  return(sce.func)
}

sce.1 <- mapply(.qualityControl, sce, e.out)
```


```{r QC cluster/variance}
.qcClusterVariance <- function(sce.1.func) {
  clusters <- quickCluster(sce.1.func)
  sce.1.func <- computeSumFactors(sce.1.func, cluster=clusters)
  sce.1.func <- logNormCounts(sce.1.func)
  sce.dec <- modelGeneVarByPoisson(sce.1.func)
  sce.top <- getTopHVGs(sce.dec, prop=0.1)
  return(list(sce.1.func, sce.dec, sce.top))
}

sec.vars <- lapply(sce.1, function(x){.qcClusterVariance(x)})

```


```{r QC dimensional reduction, cache = T}

# Function for QC dimensional reduction
.qcDimensionalReduction <- function(sce.func) {
  set.seed(10000)
  sce.func[[1]] <- denoisePCA(sce.func[[1]], subset.row=sce.func[[3]], technical=sce.func[[2]])
  set.seed(100000)
  sce.func[[1]] <- runTSNE(sce.func[[1]], dimred="PCA")
  set.seed(1000000)
  sce.func[[1]] <- runUMAP(sce.func[[1]], dimred="PCA")
  return(sce.func[[1]])
} 

sce.2 <- lapply(sec.vars, function(x){.qcDimensionalReduction(x)})

```


```{r QC clustering. cache = T}

.qcClustering <- function(sce.func) {
  g <- buildSNNGraph(sce.func, k=30)
  clust <- igraph::cluster_walktrap(g)$membership
  colLabels(sce.func) <- factor(clust)
  return(sce.func)
}

sce.2 <- lapply(sce.2, function(x){.qcClustering(x)})
```

### TSNE clusters of each dataset, still including ambient RNA

On the top is B6_1 and the bottom is B6_2. If the script worked right.

```{r plot tnse}
tnse.1 <- plotTSNE(sce.2[[1]], colour_by="label")
tnse.2 <- plotTSNE(sce.2[[2]], colour_by="label")

grid.arrange(tnse.1, tnse.2, ncol = 2)
```

## Remove ambient RNA

```{r remove ambience, cache = T}
.removeAmbience <- function(sce.func, e.out.func) {
  amb <- metadata(e.out.func)$ambient[,1]
  stripped <- sce.func[names(amb),]
  out <- removeAmbience(counts(stripped), ambient=amb, groups=colLabels(stripped))
  counts(stripped, withDimnames=FALSE) <- out
  stripped <- logNormCounts(stripped)
  return(stripped)
}

stripped <- mapply(.removeAmbience, sce.2, e.out)
```

### Marker expression by cluster before and after ambient RNA removal
 
The first three are markers for fibroblasts, endothelial cells, and immune cells (B cells + MF). The next three are all cardiomyocyte markers, with two canonical and one that was the strongest marker from our last pass at the deconvolution analysis. 

I think it's an interesting candidate for RNAscope, as there is some literature to support CM nuclear specificity.  [Cardiomyocyte-Specific Long Noncoding RNA Regulates Alternative Splicing of the Triadin Gene in the Heart](https://www.ahajournals.org/doi/10.1161/CIRCULATIONAHA.121.058017) by Zhao et al is from, last year and is worth checking out. They define it as *Trdn-as* and saw it highly and specifically expressed in cardiomyocyte nuclei via smFISH. I'll try to add a figure from that paper below. 

```{r remove ambience visual, fig.width=7, fig.height=9, results='hide', include = F}

plotAmbience <- function(sce.func, gene){
  before = plotExpression(sce.func, x="label", colour_by="label", features=gene, add_legend = F) 
  return(before)}

# List markers for fibroblasts, endothelial cells, immune, and cardiomyocytes (3x)
genes <- c("Col1a1","Pecam1", "Cd86", "Myh6", "Tnnt2", "D830005E20Rik") 


# Make sub lists of plots for each version and sample
plots.1.before <- lapply(genes, function(x){
  plotAmbience(sce.2[[1]], x)
})

plots.1.after <- lapply(genes, function(x){
  plotAmbience(stripped[[1]], x)
})

# arrange all of the plots from one sample
plots.1.be <- grid.arrange(grobs= plots.1.before, top = "Raw data", ncol = 1)
plots.1.af <- grid.arrange(grobs= plots.1.after, top = "After removing ambient RNA", ncol = 1)
plots.1 <- grid.arrange(plots.1.be,plots.1.af  , top = "B6_1", ncol = 2)


# repeat as above for other sample
plots.2.before <- lapply(genes, function(x){
  plotAmbience(sce.2[[2]], x)
})

plots.2.after <- lapply(genes, function(x){
  plotAmbience(stripped[[2]], x)
})

plots.2.be <- grid.arrange(grobs= plots.2.before, top = "Raw data", ncol = 1)
plots.2.af <- grid.arrange(grobs= plots.2.after, top = "After removing ambient RNA", ncol = 1)
plots.2 <- grid.arrange(plots.2.be,plots.2.af  , top = "B6_2", ncol = 2)
```

```{r remove ambience visual, fig.width=10, fig.height=15}
# Mesh them all together in one plot
plots.all <- grid.arrange(plots.1, plots.2, ncol = 2)
```

### Zhao 2022 Figure 1

```{r zhao figure, include = F}
url <- "https://www.ahajournals.org/cms/asset/0d6f33b7-4b50-4685-a6b3-e3cbfbc8de87/circulationaha.121.058017.fig01.jpg"
```

<center><img src="`r url`"></center>


## Doublet detection

```{r doublets and visuals}
# Find Doublets
.removeDoublets <- function(stripped.func, sec.top.func) {
  dbl.dens <- computeDoubletDensity(stripped.func, d=ncol(reducedDim(stripped.func)), subset.row=sec.top.func)
  stripped.func$DoubletScore <- dbl.dens
  cut_off <- quantile(stripped.func$DoubletScore,0.95)
  stripped.func$isDoublet <- c("no","yes")[factor(as.integer(stripped.func$DoubletScore >= cut_off), levels=c(0,1))] 
  return(stripped.func)}

# get top variable gene info
sce.top <- c(sec.vars[[1]][[3]], sec.vars[[2]][[3]])

# iterate throuigh datasets and gene sets in doublet detection function
stripped <- lapply(1:length(stripped), function(x){.removeDoublets(stripped[[x]], sec.vars[[x]][[3]])})


```

### Doublet visuals

With the doublets, we can see that they localize together in clusters. For now, they'll stay in the dataset. I'll include that data in a downstream QC.\

```{r make doublets plots, results = 'hide', include = F}
# plotUMAP with DoubletScore
doub.plot.1 <- scater::plotTSNE(stripped[[1]], colour_by="DoubletScore")
doub.plot.2 <- scater::plotTSNE(stripped[[2]], colour_by="DoubletScore")


# Make violin plots of doublet scores
doub.vln.1  <- plotColData(stripped[[1]], x="label", y="DoubletScore", colour_by="label")+
               geom_hline(yintercept = quantile(colData(stripped[[1]])$DoubletScore, 0.95),lty="dashed",color="red")

doub.vln.2  <- plotColData(stripped[[2]], x="label", y="DoubletScore", colour_by="label")+
               geom_hline(yintercept = quantile(colData(stripped[[2]])$DoubletScore, 0.95),lty="dashed",color="red")

doub.both.1 <- gridExtra::grid.arrange(tnse.1, doub.plot.1, doub.vln.1, ncol = 1, top = "B6_1")
doub.both.2 <- gridExtra::grid.arrange(tnse.2, doub.plot.2, doub.vln.2, ncol = 1, top = "B6_2")


```


```{r visualize doublets, fig.width=10, fig.height=8}
gridExtra::grid.arrange(doub.both.1, doub.both.2, ncol = 2)
```




```{r save as seurat}
# Convert to seurat
sn.clean.1 <- as.Seurat(stripped[[1]])
sn.clean.2 <- as.Seurat(stripped[[2]])

# Save as seurat
SaveH5Seurat(sn.clean.1, "jensen/results/doublets_ambient_rna/08152023/B6_1")
SaveH5Seurat(sn.clean.2, "jensen/results/doublets_ambient_rna/08152023/B6_2")

```

```{r session info, include = T}
sessionInfo()
```